console.log('This site was generated by Hugo.');
document.addEventListener("DOMContentLoaded", () => {
  const toggleButton = document.getElementById("theme-toggle");
  const html = document.documentElement;

  if (toggleButton) {
    function updateIcon(theme) {
      toggleButton.innerHTML = theme === "dark" ? "<i class=\"fas fa-sun\"></i>" : "<i class=\"fas fa-moon\"></i>";
    }

    const currentTheme = html.getAttribute("data-theme") || "dark";
    updateIcon(currentTheme);

    toggleButton.addEventListener("click", () => {
      const current = html.getAttribute("data-theme");
      const next = current === "dark" ? "light" : "dark";
      html.setAttribute("data-theme", next);
      localStorage.setItem("theme", next);
      updateIcon(next);
    });
  }

  // 外部リンクを新規タブで開く
  // document.querySelectorAll('a').forEach(link => {
  //   const hostname = window.location.hostname;
  //   const linkHostname = new URL(link.href).hostname;
  //   if (linkHostname !== hostname && linkHostname.length > 0) {
  //     link.setAttribute('target', '_blank');
  //     link.setAttribute('rel', 'noopener');
  //   }
  // });

  // Image preview functionality
  const images = document.querySelectorAll('main img:not(.link-card__image)');
  
  const modal = document.createElement('div');
  modal.classList.add('image-preview-modal');
  const modalContent = document.createElement('img');
  modalContent.classList.add('image-preview-content');
  modal.appendChild(modalContent);
  document.body.appendChild(modal);

  images.forEach(img => {
    img.style.cursor = 'pointer'; // Add pointer cursor to indicate clickability
    img.addEventListener('click', () => {
      modal.classList.add('active');
      modalContent.src = img.src;
      document.body.classList.add('no-scroll');
    });
  });

  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.classList.remove('active');
      document.body.classList.remove('no-scroll');
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal.classList.contains('active')) {
      modal.classList.remove('active');
      document.body.classList.remove('no-scroll');
    }
  });

  // Add copy button to code blocks
  document.querySelectorAll('.highlight').forEach((highlightDiv) => {
    // Hugo can generate code blocks with line numbers (using a table) or without.
    // We need to handle both cases to find the correct element containing the code.
    let codeElement = highlightDiv.querySelector('table.lntable td:nth-child(2) code');
    let codeContainer = null;

    if (codeElement) {
      // This is a code block with line numbers. The container is the parent <pre> of the code cell.
      codeContainer = codeElement.parentElement;
    } else {
      // This is a code block without line numbers.
      codeElement = highlightDiv.querySelector('pre > code');
      if (codeElement) {
        codeContainer = codeElement.parentElement;
      }
    }

    if (!codeElement) {
      return;
    }

    // Ensure we have a sticky toolbar as the first child for housing buttons
    let toolbar = highlightDiv.querySelector('.copy-code-toolbar');
    if (!toolbar) {
      toolbar = document.createElement('div');
      toolbar.className = 'copy-code-toolbar';
      highlightDiv.insertBefore(toolbar, highlightDiv.firstChild);
    }

    const button = document.createElement('button');
    button.className = 'copy-code-button';
    button.innerText = 'copy';
    button.setAttribute('aria-label', 'Copy code to clipboard');

    // Add the button into the toolbar
    toolbar.appendChild(button);

    // No scroll-follow behavior per request: ensure any previous transform is cleared
    toolbar.style.transform = 'none';

    button.addEventListener('click', () => {
      const codeToCopy = codeElement.textContent;
      navigator.clipboard.writeText(codeToCopy).then(() => {
        button.innerText = 'copied!';
        button.classList.add('copied');
        setTimeout(() => {
          button.innerText = 'copy';
          button.classList.remove('copied');
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy code: ', err);
        button.innerText = 'Failed';
      });
    });
  });

  // Scrollspy for Table of Contents
  const tocLinks = document.querySelectorAll('#TableOfContents a');
  const tocContainer = document.getElementById('toc-container');
  const header = document.querySelector('header[role="banner"]');

  if (tocLinks.length > 0 && tocContainer && header) {
    const sections = Array.from(tocLinks).map(link => {
      const targetId = link.getAttribute('href');
      if (targetId && targetId.startsWith('#')) {
        const section = document.getElementById(targetId.substring(1));
        if (section) {
          return { link: link.parentElement, section: section };
        }
      }
      return null;
    }).filter(item => item !== null);

    if (sections.length > 0) {
      const onScroll = () => {
        const offset = 180; // ヘッダーの高さなどを考慮したオフセット

        const scrollPosition = window.scrollY || document.documentElement.scrollTop;
        let currentSection = null;

        // ヘッダーの高さ
        const headerHeight = header.offsetHeight;

        // スクロール位置がヘッダーの高さより大きい場合、scrolledクラスを追加
        if (scrollPosition > headerHeight) {
          tocContainer.classList.add('scrolled');
        } else {
          tocContainer.classList.remove('scrolled');
        }

        // すべてのセクションをチェックし、現在のスクロール位置に最も近いセクションを見つける
        for (let i = sections.length - 1; i >= 0; i--) { // 後ろからループ
          const item = sections[i];
          if (item.section.offsetTop - offset <= scrollPosition) {
            currentSection = item;
            break; // 見つかったらループを抜ける
          }
        }
        
        // 一旦すべてのactiveクラスを削除
        sections.forEach(item => {
          item.link.classList.remove('active');
        });

        // 現在のセクションに対応するli要素にactiveクラスを追加
        if (currentSection) {
          currentSection.link.classList.add('active');

          const tocContainer = document.getElementById('toc-container');
          if (tocContainer) {
            const activeLink = currentSection.link;

            const containerHeight = tocContainer.clientHeight;
            // アクティブなリンクのTOCコンテナ内での相対的な上端位置を正確に計算
            const relativeLinkOffsetTop = activeLink.getBoundingClientRect().top - tocContainer.getBoundingClientRect().top + tocContainer.scrollTop;
            const linkHeight = activeLink.offsetHeight;
            const containerScrollTop = tocContainer.scrollTop;

            // アクティブなリンクがコンテナの上端より上にある場合
            if (relativeLinkOffsetTop < containerScrollTop) {
              tocContainer.scrollTop = relativeLinkOffsetTop;
            } 
            // アクティブなリンクがコンテナの下端より下にある場合
            else if (relativeLinkOffsetTop + linkHeight > containerScrollTop + containerHeight) {
              tocContainer.scrollTop = relativeLinkOffsetTop + linkHeight - containerHeight;
            }
          }
        }
      };

      // スクロールイベントの最適化（スロットリング）
      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            onScroll();
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });
      
      // 初期表示時にも実行
      onScroll();
    }
  }

  // TOC Collapse for mobile
  const tocContainerForCollapse = document.getElementById('toc-container');
  if (tocContainerForCollapse) {
    const tocTitle = document.getElementById('toc-title');
    const toc = document.getElementById('toc');

    if (tocTitle && toc) {
      tocTitle.addEventListener('click', () => {
        if (window.innerWidth < 1200) {
          tocContainerForCollapse.classList.toggle('collapsed');
        }
      });
    }

    const initTocCollapse = () => {
      if (window.innerWidth < 1200) {
        tocContainerForCollapse.classList.add('collapsible');
        tocContainerForCollapse.classList.add('collapsed');
      } else {
        tocContainerForCollapse.classList.remove('collapsible');
        tocContainerForCollapse.classList.remove('collapsed');
      }
    };

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(initTocCollapse, 250);
    });

    initTocCollapse();
  }
});
